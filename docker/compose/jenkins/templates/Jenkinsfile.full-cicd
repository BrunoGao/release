@Library('jenkins-shared-library') _

pipeline {
    agent any
    
    environment {
        REGISTRY = "${env.DOCKER_REGISTRY ?: 'localhost:5001'}"
        APP_NAME = "${env.JOB_NAME.split('/')[0].toLowerCase()}"
        GIT_SHORT_COMMIT = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
        IMAGE_TAG = "${env.BUILD_NUMBER}-${GIT_SHORT_COMMIT}"
        PLATFORMS = 'linux/amd64,linux/arm64'
        KUBECONFIG_ID = 'k8s-config'
    }
    
    parameters {
        choice(
            name: 'DEPLOY_ENV',
            choices: ['dev', 'staging', 'prod'],
            description: 'éƒ¨ç½²ç¯å¢ƒ'
        )
        booleanParam(
            name: 'SKIP_TESTS', 
            defaultValue: false, 
            description: 'è·³è¿‡æµ‹è¯•é˜¶æ®µ'
        )
        booleanParam(
            name: 'DEPLOY_TO_K8S',
            defaultValue: true,
            description: 'éƒ¨ç½²åˆ°K8sé›†ç¾¤'
        )
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '50', daysToKeepStr: '30'))
        timeout(time: 60, unit: 'MINUTES')
        timestamps()
        ansiColor('xterm')
        skipDefaultCheckout(false)
    }
    
    stages {
        stage('ğŸ” ç¯å¢ƒæ£€æŸ¥') {
            steps {
                script {
                    echo "=== æ„å»ºä¿¡æ¯ ==="
                    echo "App: ${env.APP_NAME}"
                    echo "Tag: ${env.IMAGE_TAG}"
                    echo "Registry: ${env.REGISTRY}"
                    echo "Environment: ${params.DEPLOY_ENV}"
                    echo "Git Commit: ${env.GIT_SHORT_COMMIT}"
                    
                    // æ£€æŸ¥å¿…è¦å·¥å…·
                    sh '''
                        echo "=== å·¥å…·ç‰ˆæœ¬æ£€æŸ¥ ==="
                        docker --version
                        docker buildx version || echo "âŒ buildx not available"
                        kubectl version --client || echo "âš ï¸  kubectl not available"
                        git --version
                    '''
                    
                    // æ£€æŸ¥Registryè¿æ¥
                    sh 'curl -f ${REGISTRY}/v2/ || echo "âš ï¸  Registryè¿æ¥æ£€æŸ¥"'
                }
            }
        }
        
        stage('ğŸ“¥ ä»£ç æ£€å‡º') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT = sh(returnStdout: true, script: 'git rev-parse HEAD').trim()
                    env.GIT_BRANCH = sh(returnStdout: true, script: 'git rev-parse --abbrev-ref HEAD').trim()
                    
                    // æ£€æµ‹é¡¹ç›®ç±»å‹
                    if (fileExists('package.json')) {
                        env.PROJECT_TYPE = 'nodejs'
                    } else if (fileExists('pom.xml')) {
                        env.PROJECT_TYPE = 'maven'
                    } else if (fileExists('build.gradle')) {
                        env.PROJECT_TYPE = 'gradle'  
                    } else if (fileExists('requirements.txt')) {
                        env.PROJECT_TYPE = 'python'
                    } else {
                        env.PROJECT_TYPE = 'docker'
                    }
                    
                    echo "é¡¹ç›®ç±»å‹: ${env.PROJECT_TYPE}"
                }
            }
        }
        
        stage('ğŸ”§ ä¾èµ–å®‰è£…') {
            when { not { params.SKIP_TESTS } }
            steps {
                script {
                    switch(env.PROJECT_TYPE) {
                        case 'nodejs':
                            sh 'npm ci --production=false'
                            break
                        case 'maven':
                            sh 'mvn dependency:resolve'
                            break
                        case 'gradle':
                            sh './gradlew dependencies'
                            break
                        case 'python':
                            sh 'pip install -r requirements.txt'
                            break
                        default:
                            echo "è·³è¿‡ä¾èµ–å®‰è£…ï¼Œé¡¹ç›®ç±»å‹: ${env.PROJECT_TYPE}"
                    }
                }
            }
        }
        
        stage('ğŸ§ª ä»£ç æ£€æŸ¥') {
            when { not { params.SKIP_TESTS } }
            parallel {
                stage('è¯­æ³•æ£€æŸ¥') {
                    steps {
                        script {
                            switch(env.PROJECT_TYPE) {
                                case 'nodejs':
                                    sh 'npm run lint || echo "æ— lintè„šæœ¬"'
                                    break
                                case 'python':
                                    sh 'flake8 . || echo "æ— flake8æ£€æŸ¥"'
                                    break
                                default:
                                    echo "è·³è¿‡è¯­æ³•æ£€æŸ¥"
                            }
                        }
                    }
                }
                
                stage('å®‰å…¨æ‰«æ') {
                    steps {
                        script {
                            // ä¾èµ–å®‰å…¨æ‰«æ
                            switch(env.PROJECT_TYPE) {
                                case 'nodejs':
                                    sh 'npm audit --audit-level=high || echo "å‘ç°å®‰å…¨é—®é¢˜"'
                                    break
                                case 'python':
                                    sh 'safety check || echo "å®‰å…¨æ£€æŸ¥å®Œæˆ"'
                                    break
                                default:
                                    echo "è·³è¿‡å®‰å…¨æ‰«æ"
                            }
                        }
                    }
                }
            }
        }
        
        stage('ğŸ§ª å•å…ƒæµ‹è¯•') {
            when { not { params.SKIP_TESTS } }
            steps {
                script {
                    switch(env.PROJECT_TYPE) {
                        case 'nodejs':
                            sh 'npm test || echo "æµ‹è¯•æ‰§è¡Œå®Œæˆ"'
                            break
                        case 'maven':
                            sh 'mvn test'
                            break
                        case 'gradle':
                            sh './gradlew test'
                            break
                        case 'python':
                            sh 'python -m pytest || echo "æµ‹è¯•æ‰§è¡Œå®Œæˆ"'
                            break
                        default:
                            echo "è·³è¿‡å•å…ƒæµ‹è¯•ï¼Œé¡¹ç›®ç±»å‹: ${env.PROJECT_TYPE}"
                    }
                }
            }
            post {
                always {
                    // å‘å¸ƒæµ‹è¯•ç»“æœ
                    publishTestResults(
                        testResultsPattern: '**/test-results.xml,**/TEST-*.xml',
                        allowEmptyResults: true
                    )
                }
            }
        }
        
        stage('ğŸ³ å¤šå¹³å°æ„å»º') {
            steps {
                script {
                    // ç¡®ä¿Dockerfileå­˜åœ¨
                    if (!fileExists('Dockerfile')) {
                        echo "åˆ›å»ºé»˜è®¤Dockerfile..."
                        writeFile file: 'Dockerfile', text: """
FROM alpine:latest
RUN apk add --no-cache curl
COPY . /app
WORKDIR /app
EXPOSE 8080
CMD echo "Hello from ${env.APP_NAME}"
"""
                    }
                    
                    // ä½¿ç”¨å…±äº«åº“æ„å»ºå¤šå¹³å°é•œåƒ
                    def buildResult = buildMultiPlatformImage([
                        registry: env.REGISTRY,
                        imageName: env.APP_NAME,
                        platforms: env.PLATFORMS,
                        tags: ['latest', env.IMAGE_TAG, "branch-${env.GIT_BRANCH}"],
                        push: true
                    ])
                    
                    env.BUILT_IMAGE = "${buildResult.registry}/${buildResult.imageName}:${env.IMAGE_TAG}"
                    echo "âœ… é•œåƒæ„å»ºå®Œæˆ: ${env.BUILT_IMAGE}"
                }
            }
        }
        
        stage('ğŸ”’ é•œåƒæ‰«æ') {
            when { 
                expression { params.DEPLOY_ENV == 'prod' }
            }
            steps {
                script {
                    echo "æ‰§è¡Œç”Ÿäº§ç¯å¢ƒé•œåƒå®‰å…¨æ‰«æ..."
                    sh """
                        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \\
                            aquasec/trivy image --exit-code 0 --severity HIGH,CRITICAL \\
                            ${env.BUILT_IMAGE} || echo "æ‰«æå®Œæˆ"
                    """
                }
            }
        }
        
        stage('ğŸš€ éƒ¨ç½²') {
            parallel {
                stage('K8séƒ¨ç½²') {
                    when { 
                        expression { params.DEPLOY_TO_K8S && fileExists('k8s/') }
                    }
                    steps {
                        script {
                            def deployResult = deployToK8s([
                                namespace: "${env.APP_NAME}-${params.DEPLOY_ENV}",
                                appName: env.APP_NAME,
                                image: env.BUILT_IMAGE,
                                manifests: 'k8s/',
                                kubeconfig: env.KUBECONFIG_ID,
                                dryRun: false,
                                waitForRollout: true
                            ])
                            
                            echo "âœ… K8séƒ¨ç½²å®Œæˆ: ${deployResult.namespace}/${deployResult.appName}"
                        }
                    }
                }
                
                stage('Docker Swarméƒ¨ç½²') {
                    when { 
                        expression { !params.DEPLOY_TO_K8S && fileExists('docker-compose.prod.yml') }
                    }
                    steps {
                        script {
                            echo "éƒ¨ç½²åˆ°Docker Swarm..."
                            sh """
                                export IMAGE=${env.BUILT_IMAGE}
                                docker stack deploy --compose-file docker-compose.prod.yml ${env.APP_NAME}-${params.DEPLOY_ENV}
                            """
                        }
                    }
                }
            }
        }
        
        stage('âœ… éƒ¨ç½²éªŒè¯') {
            steps {
                script {
                    echo "æ‰§è¡Œéƒ¨ç½²éªŒè¯..."
                    
                    if (params.DEPLOY_TO_K8S) {
                        // K8så¥åº·æ£€æŸ¥
                        sh """
                            kubectl get pods -n ${env.APP_NAME}-${params.DEPLOY_ENV} -l app=${env.APP_NAME}
                            kubectl top pods -n ${env.APP_NAME}-${params.DEPLOY_ENV} -l app=${env.APP_NAME} || echo "èµ„æºä½¿ç”¨æƒ…å†µ"
                        """
                    } else {
                        // Dockerå®¹å™¨å¥åº·æ£€æŸ¥
                        sh "docker service ls | grep ${env.APP_NAME}-${params.DEPLOY_ENV} || echo 'æœåŠ¡çŠ¶æ€æ£€æŸ¥'"
                    }
                    
                    // åº”ç”¨å¥åº·æ£€æŸ¥
                    sh 'curl -f http://localhost:8080/health || echo "åº”ç”¨å¥åº·æ£€æŸ¥"'
                }
            }
        }
    }
    
    post {
        always {
            echo "=== æ„å»ºç»Ÿè®¡ ==="
            echo "æ„å»ºæ—¶é•¿: ${currentBuild.durationString}"
            echo "æ„å»ºç»“æœ: ${currentBuild.currentResult}"
            
            // æ¸…ç†å·¥ä½œç©ºé—´
            cleanWs(
                cleanWhenAborted: true,
                cleanWhenFailure: false,
                cleanWhenNotBuilt: false,
                cleanWhenSuccess: true,
                cleanWhenUnstable: false,
                deleteDirs: true
            )
        }
        
        success {
            echo "ğŸ‰ Pipelineæ‰§è¡ŒæˆåŠŸï¼"
            
            // å‘é€æˆåŠŸé€šçŸ¥
            script {
                if (env.SLACK_WEBHOOK) {
                    slackSend(
                        color: 'good',
                        message: """âœ… éƒ¨ç½²æˆåŠŸ
App: ${env.APP_NAME}
Environment: ${params.DEPLOY_ENV}
Image: ${env.BUILT_IMAGE}
Duration: ${currentBuild.durationString}"""
                    )
                }
            }
        }
        
        failure {
            echo "âŒ Pipelineæ‰§è¡Œå¤±è´¥ï¼"
            
            // å‘é€å¤±è´¥é€šçŸ¥
            script {
                if (env.SLACK_WEBHOOK) {
                    slackSend(
                        color: 'danger',
                        message: """âŒ éƒ¨ç½²å¤±è´¥
App: ${env.APP_NAME}
Environment: ${params.DEPLOY_ENV}  
Branch: ${env.GIT_BRANCH}
Build: ${env.BUILD_URL}"""
                    )
                }
            }
        }
        
        unstable {
            echo "âš ï¸ Pipelineæ‰§è¡Œä¸ç¨³å®š"
        }
    }
} 