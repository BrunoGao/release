# è®¾å¤‡ç®¡ç†ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ

## 1. é¡¹ç›®èƒŒæ™¯ä¸ç›®æ ‡

### 1.1 ç³»ç»Ÿæ¦‚è¿°
LJWXå¥åº·ç®¡ç†ç³»ç»Ÿæ˜¯ä¸€ä¸ªåŸºäºå¾®æœåŠ¡æ¶æ„çš„ä¼ä¸šçº§å¥åº·ç›‘æµ‹å¹³å°ï¼ŒåŒ…å«è®¾å¤‡æ•°æ®é‡‡é›†ã€å­˜å‚¨ã€å¤„ç†ã€æŸ¥è¯¢å’Œæ˜¾ç¤ºçš„å®Œæ•´æ•°æ®æµã€‚ç³»ç»Ÿæ ¸å¿ƒåŒ…å«ï¼š

- **ljwx-watch**: HarmonyOSå¥åº·æ•°æ®é‡‡é›†æœåŠ¡
- **ljwx-bigscreen**: Python Flaskè®¾å¤‡ä¿¡æ¯å¤„ç†å¼•æ“  
- **ljwx-boot**: Java Spring Bootåç«¯APIæœåŠ¡
- **ljwx-admin**: Vue.jså‰ç«¯ç®¡ç†ç•Œé¢

### 1.2 ä¼˜åŒ–ç›®æ ‡
- **æ€§èƒ½æå‡**: æ•´ä½“ç³»ç»Ÿå¤„ç†èƒ½åŠ›æå‡150%
- **å»¶è¿Ÿä¼˜åŒ–**: ç«¯åˆ°ç«¯æ•°æ®å»¶è¿Ÿä»30ç§’é™è‡³10ç§’ä»¥å†…
- **å¹¶å‘ä¼˜åŒ–**: æ”¯æŒ2000+è®¾å¤‡å¹¶å‘å¤„ç†
- **èµ„æºä¼˜åŒ–**: CPUä½¿ç”¨ç‡é™ä½40%ï¼Œå†…å­˜ä½¿ç”¨ç‡é™ä½30%

## 2. ç°çŠ¶åˆ†æ

### 2.1 ç³»ç»Ÿæ¶æ„
```mermaid
graph LR
    A[ljwx-watchè®¾å¤‡é‡‡é›†] --> B[ljwx-bigscreenæ‰¹å¤„ç†]
    B --> C[MySQLæ•°æ®å­˜å‚¨]
    C --> D[ljwx-boot APIæœåŠ¡]
    D --> E[ljwx-adminå‰ç«¯å±•ç¤º]
    B --> F[Redisç¼“å­˜å±‚]
    F --> D
```

### 2.2 æ ¸å¿ƒæ•°æ®åº“è¡¨ç»“æ„

#### t_device_info (è®¾å¤‡åŸºæœ¬ä¿¡æ¯è¡¨)
- **ä¸»é”®**: id (bigint)
- **æ ¸å¿ƒå­—æ®µ**: serial_number, system_software_version, battery_level, wearable_status, charging_status
- **å…³è”å­—æ®µ**: customer_id (å¤šç§Ÿæˆ·), user_id (ç”¨æˆ·ç»‘å®š), org_id (ç»„ç»‡)
- **æ—¶é—´å­—æ®µ**: timestamp (è®¾å¤‡æ—¶é—´), update_time (æ›´æ–°æ—¶é—´)
- **å½“å‰è®°å½•æ•°**: ~10ä¸‡+ (æŒç»­å¢é•¿)

#### t_device_info_history (è®¾å¤‡å†å²ä¿¡æ¯è¡¨)  
- **ä¸»é”®**: id (bigint)
- **å†å²å­—æ®µ**: åŒ…å«t_device_infoæ‰€æœ‰å­—æ®µçš„å†å²å¿«ç…§
- **åˆ†åŒºå­—æ®µ**: timestamp (å»ºè®®æŒ‰æœˆåˆ†åŒº)
- **å½“å‰è®°å½•æ•°**: ~500ä¸‡+ (å¿«é€Ÿå¢é•¿)

### 2.3 ç°æœ‰ç´¢å¼•åˆ†æ
```sql
-- å½“å‰ç´¢å¼•çŠ¶å†µ
PRIMARY KEY (id)
INDEX idx_serial_number (serial_number)
INDEX idx_customer_id (customer_id) 
INDEX idx_timestamp (timestamp)
INDEX idx_update_time (update_time)

-- ç¼ºå¤±çš„å…³é”®ç´¢å¼•
-- è®¾å¤‡çŠ¶æ€æŸ¥è¯¢ä¼˜åŒ–ç´¢å¼•
-- ç”¨æˆ·è®¾å¤‡ç»‘å®šæŸ¥è¯¢ä¼˜åŒ–ç´¢å¼•  
-- å®æ—¶çŠ¶æ€åˆ¤æ–­ä¼˜åŒ–ç´¢å¼•
```

## 3. æ€§èƒ½ç“¶é¢ˆåˆ†æ

### 3.1 æ•°æ®é‡‡é›†å±‚ç“¶é¢ˆ (ljwx-watch)

#### é—®é¢˜ç‚¹1: ç»Ÿä¸€å®šæ—¶å™¨è°ƒåº¦æ•ˆç‡ä½ä¸‹
**ä½ç½®**: `ljwx-watch/HealthDataService.java:1038-1108`

**é—®é¢˜æè¿°**:
```java
// å½“å‰å®ç°ï¼šæ‰€æœ‰æ•°æ®é‡‡é›†ä½¿ç”¨ç»Ÿä¸€5ç§’å®šæ—¶å™¨
masterTimer.schedule(new TimerTask() {
    @Override
    public void run() {
        tick++;
        // æ‰€æœ‰ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†éƒ½åœ¨åŒä¸€ä¸ªå®šæ—¶å™¨ä¸­è½®è¯¢
        if (stepSupported && tick % stepTickInterval == 0) {
            getStepData(startTime, currentTime);
        }
        if (heartRateSupported && tick % heartRateTickInterval == 0) {
            getHeartRate(startTime, currentTime);  
        }
        // ... æ›´å¤šä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†
    }
}, 0, basePeriod * 1000);
```

**æ€§èƒ½å½±å“**:
- CPUå ç”¨é›†ä¸­åœ¨å®šæ—¶å™¨è§¦å‘æ—¶åˆ»ï¼Œé€ æˆæ€§èƒ½å³°å€¼
- æ‰€æœ‰ä¼ æ„Ÿå™¨äº‰å¤ºç³»ç»Ÿèµ„æºï¼Œæ•°æ®é‡‡é›†è´¨é‡ä¸‹é™
- ç”µæ± æ¶ˆè€—ä¸¥é‡ï¼Œè®¾å¤‡ç»­èˆªæ—¶é—´ç¼©çŸ­

#### é—®é¢˜ç‚¹2: ç¼ºä¹æ™ºèƒ½çœç”µæœºåˆ¶
**ä½ç½®**: `ljwx-watch/HealthDataService.java:560-596`

**é—®é¢˜æè¿°**:
- ä½©æˆ´çŠ¶æ€æ£€æµ‹å­˜åœ¨ä½†æœªç”¨äºçœç”µä¼˜åŒ–
- æ— æ ¹æ®ç”¨æˆ·æ´»åŠ¨çŠ¶æ€åŠ¨æ€è°ƒæ•´é‡‡é›†é¢‘ç‡çš„æœºåˆ¶
- æ•°æ®ä¸Šä¼ é¢‘ç‡å›ºå®šï¼Œæ— æ‰¹é‡ä¼˜åŒ–

### 3.2 æ‰¹å¤„ç†å±‚ç“¶é¢ˆ (ljwx-bigscreen)

#### é—®é¢˜ç‚¹1: é˜Ÿåˆ—å®¹é‡é™åˆ¶å¯¼è‡´é™çº§å¤„ç†
**ä½ç½®**: `ljwx-bigscreen/device.py:48-74`

**é—®é¢˜æè¿°**:
```python
# å½“å‰å®ç°ï¼šé˜Ÿåˆ—æ»¡æ—¶é™çº§åˆ°åŒæ­¥å¤„ç†
try:
    success = batch_processor.submit(device_info)
    if success:
        return jsonify({"status": "success", "message": "è®¾å¤‡ä¿¡æ¯å·²æ¥æ”¶ï¼Œæ­£åœ¨æ‰¹é‡å¤„ç†"})
    else:
        print(f"ğŸ“± é˜Ÿåˆ—æ»¡ï¼Œé™çº§åˆ°åŒæ­¥å¤„ç†: {device_id}")
        return upload_device_info_sync(device_info)  # æ€§èƒ½ä¸‹é™çš„é™çº§å¤„ç†
except Exception as e:
    return upload_device_info_sync(device_info)     # å¼‚å¸¸æ—¶çš„é™çº§å¤„ç†
```

**æ€§èƒ½å½±å“**:
- é«˜å¹¶å‘æ—¶(400-1000è®¾å¤‡)é¢‘ç¹è§¦å‘åŒæ­¥é™çº§
- é™çº§å¤„ç†æ—¶å»¶è¿Ÿæ˜¾è‘—å¢åŠ (200ms â†’ 2000ms+)
- ç³»ç»Ÿç¨³å®šæ€§ä¸‹é™ï¼Œç”¨æˆ·ä½“éªŒå˜å·®

#### é—®é¢˜ç‚¹2: è®¾å¤‡çŠ¶æ€æ£€æŸ¥æ•ˆç‡ä½ä¸‹
**ä½ç½®**: `ljwx-bigscreen/device.py:1111-1115`

**é—®é¢˜æè¿°**:
```python
def check_device_real_status(device_sn, customer_id):
    try:
        from datetime import datetime, timedelta
        i = get_interface_call_interval(customer_id)
        t = datetime.now() - timedelta(seconds=i)
        h = db.session.query(DeviceInfoHistory).filter(
            DeviceInfoHistory.serial_number == device_sn,
            DeviceInfoHistory.timestamp >= t,
            DeviceInfoHistory.is_deleted.is_(False)
        ).first()
        status = 'ACTIVE' if h else 'INACTIVE'
        return status
    except Exception as e:
        return 'INACTIVE'
```

**æ€§èƒ½å½±å“**:
- æ¯æ¬¡çŠ¶æ€æ£€æŸ¥éƒ½æŸ¥è¯¢å†å²è¡¨ï¼Œæ•°æ®åº“å‹åŠ›å·¨å¤§
- éšç€å†å²æ•°æ®å¢é•¿ï¼ŒæŸ¥è¯¢å»¶è¿Ÿçº¿æ€§å¢åŠ 
- ç¼ºå°‘ç¼“å­˜æœºåˆ¶ï¼Œé‡å¤æŸ¥è¯¢æµªè´¹èµ„æº

### 3.3 æ•°æ®åº“å±‚ç“¶é¢ˆ

#### é—®é¢˜ç‚¹1: å†å²è¡¨æ— åˆ†åŒºç­–ç•¥
**ä½ç½®**: `t_device_info_history` è¡¨ç»“æ„

**é—®é¢˜æè¿°**:
- 500ä¸‡+è®°å½•çš„å†å²è¡¨æ— åˆ†åŒºï¼Œå…¨è¡¨æ‰«ææ€§èƒ½å·®
- å†å²æ•°æ®æ°¸ä¹…ä¿ç•™ï¼Œå­˜å‚¨ç©ºé—´æ— é™å¢é•¿
- æŸ¥è¯¢æ€§èƒ½éšæ—¶é—´çº¿æ€§ä¸‹é™

#### é—®é¢˜ç‚¹2: ç¼ºä¹é’ˆå¯¹æ€§èƒ½ä¼˜åŒ–ç´¢å¼•
**é—®é¢˜æè¿°**:
```sql
-- ç¼ºå¤±çš„å…³é”®ç»„åˆç´¢å¼•
-- 1. è®¾å¤‡çŠ¶æ€æŸ¥è¯¢åœºæ™¯
SELECT * FROM t_device_info_history 
WHERE serial_number = ? AND timestamp >= ? AND is_deleted = 0;

-- 2. ç”¨æˆ·è®¾å¤‡ç»‘å®šæŸ¥è¯¢åœºæ™¯  
SELECT * FROM t_device_info 
WHERE customer_id = ? AND serial_number IN (...) AND is_deleted = 0;

-- 3. æ‰¹é‡è®¾å¤‡çŠ¶æ€æ£€æŸ¥åœºæ™¯
SELECT serial_number, MAX(timestamp) FROM t_device_info_history
WHERE serial_number IN (...) AND is_deleted = 0
GROUP BY serial_number;
```

### 3.4 æœåŠ¡å±‚ç“¶é¢ˆ (ljwx-boot)

#### é—®é¢˜ç‚¹1: å¤æ‚å¤šè¡¨å…³è”æŸ¥è¯¢
**ä½ç½®**: `ljwx-boot/TDeviceInfoServiceImpl.java`

**é—®é¢˜æè¿°**:
```java
// å¤æ‚çš„å­æŸ¥è¯¢é€»è¾‘ï¼Œæ€§èƒ½éšè®¾å¤‡æ•°é‡çº¿æ€§ä¸‹é™
public List<TDeviceInfo> getDeviceInfoList(DeviceInfoQuery query) {
    return baseMapper.selectList(new QueryWrapper<TDeviceInfo>()
        .eq("customer_id", query.getCustomerId())
        .in("serial_number", 
            // å­æŸ¥è¯¢è·å–ç”¨æˆ·ç»‘å®šçš„è®¾å¤‡åºåˆ—å·
            userInfoService.getUserDeviceSerialNumbers(query.getOrgId())
        )
        .orderByDesc("update_time")
    );
}
```

**æ€§èƒ½å½±å“**:
- N+1æŸ¥è¯¢é—®é¢˜ï¼Œå¤§é‡è®¾å¤‡æ—¶æ€§èƒ½æ€¥å‰§ä¸‹é™
- ç¼ºä¹æœ‰æ•ˆçš„ç¼“å­˜ç­–ç•¥ï¼Œé‡å¤æŸ¥è¯¢æ•°æ®åº“
- åˆ†é¡µæŸ¥è¯¢ä½¿ç”¨OFFSETæ–¹å¼ï¼Œæ·±åˆ†é¡µæ€§èƒ½å·®

## 4. ç»¼åˆä¼˜åŒ–ç­–ç•¥

### 4.1 æ•°æ®é‡‡é›†å±‚ä¼˜åŒ– (ljwx-watch)

#### ä¼˜åŒ–æ–¹æ¡ˆ1: åˆ†å±‚æ™ºèƒ½è°ƒåº¦ç³»ç»Ÿ
```java
/**
 * æ™ºèƒ½å¥åº·æ•°æ®é‡‡é›†è°ƒåº¦å™¨
 * æ ¹æ®æ•°æ®é‡è¦æ€§å’Œè®¾å¤‡çŠ¶æ€åˆ†å±‚è°ƒåº¦
 */
public class IntelligentHealthScheduler {
    // å…³é”®æ•°æ®é«˜é¢‘é‡‡é›†å™¨ (å¿ƒç‡ã€è¡€æ°§)
    private ScheduledExecutorService criticalDataExecutor = 
        Executors.newScheduledThreadPool(2);
    
    // çŠ¶æ€æ•°æ®ä¸­é¢‘é‡‡é›†å™¨ (ä½“æ¸©ã€å‹åŠ›ã€ä½©æˆ´çŠ¶æ€)  
    private ScheduledExecutorService statusDataExecutor = 
        Executors.newScheduledThreadPool(2);
        
    // ç»Ÿè®¡æ•°æ®ä½é¢‘é‡‡é›†å™¨ (æ­¥æ•°ã€å¡è·¯é‡Œã€ç¡çœ )
    private ScheduledExecutorService statisticsDataExecutor = 
        Executors.newScheduledThreadPool(1);
    
    public void startIntelligentCollection() {
        // å…³é”®æ•°æ®: 5ç§’é—´éš”é‡‡é›†
        criticalDataExecutor.scheduleAtFixedRate(
            this::collectCriticalData, 0, 5, TimeUnit.SECONDS);
            
        // çŠ¶æ€æ•°æ®: 30ç§’é—´éš”é‡‡é›†  
        statusDataExecutor.scheduleAtFixedRate(
            this::collectStatusData, 0, 30, TimeUnit.SECONDS);
            
        // ç»Ÿè®¡æ•°æ®: 5åˆ†é’Ÿé—´éš”é‡‡é›†
        statisticsDataExecutor.scheduleAtFixedRate(
            this::collectStatisticsData, 0, 300, TimeUnit.SECONDS);
    }
    
    private void collectCriticalData() {
        if (isDeviceWorn() && isUserActive()) {
            // å¹¶è¡Œé‡‡é›†å…³é”®å¥åº·æ•°æ®
            CompletableFuture.allOf(
                CompletableFuture.runAsync(this::getHeartRate),
                CompletableFuture.runAsync(this::getBloodOxygen)
            ).join();
        }
    }
}
```

#### ä¼˜åŒ–æ–¹æ¡ˆ2: æ™ºèƒ½çœç”µæœºåˆ¶
```java
/**
 * æ™ºèƒ½çœç”µæ§åˆ¶å™¨
 * æ ¹æ®ä½©æˆ´çŠ¶æ€å’Œç”¨æˆ·æ´»åŠ¨åŠ¨æ€è°ƒæ•´é‡‡é›†ç­–ç•¥
 */
public class SmartPowerManager {
    private boolean isDeviceWorn = true;
    private UserActivityLevel activityLevel = UserActivityLevel.NORMAL;
    
    public void updateCollectionStrategy() {
        if (!isDeviceWorn) {
            // éä½©æˆ´çŠ¶æ€ï¼šä»…ä¿ç•™è®¾å¤‡çŠ¶æ€ç›‘æµ‹
            pauseHealthDataCollection();
            scheduleWearDetection();
        } else {
            switch (activityLevel) {
                case HIGH:
                    // é«˜æ´»åŠ¨çŠ¶æ€ï¼šæé«˜å¿ƒç‡è¡€æ°§é‡‡é›†é¢‘ç‡
                    setCriticalDataInterval(3); // 3ç§’é—´éš”
                    break;
                case LOW:  
                    // ä½æ´»åŠ¨çŠ¶æ€ï¼šé™ä½é‡‡é›†é¢‘ç‡èŠ‚çœç”µé‡
                    setCriticalDataInterval(10); // 10ç§’é—´éš”
                    break;
                default:
                    setCriticalDataInterval(5); // é»˜è®¤5ç§’é—´éš”
            }
        }
    }
    
    public void enableBatchUpload() {
        // æ‰¹é‡ä¸Šä¼ ç­–ç•¥ï¼šç´¯ç§¯10æ¡æ•°æ®æˆ–é—´éš”60ç§’ä¸Šä¼ 
        HealthDataCache cache = new HealthDataCache(10, 60);
        cache.setBatchUploadCallback(this::uploadBatchData);
    }
}
```

**é¢„æœŸæ•ˆæœ**:
- è®¾å¤‡ç”µæ± ç»­èˆªæå‡30-50%
- CPUä½¿ç”¨ç‡é™ä½60%
- å…³é”®æ•°æ®å®æ—¶æ€§ä¿æŒï¼Œéå…³é”®æ•°æ®å¯æ¥å—å»¶è¿Ÿ
- ç”¨æˆ·ä½“éªŒæå‡ï¼Œè®¾å¤‡å“åº”æ›´æµç•…

### 4.2 æ‰¹å¤„ç†å±‚ä¼˜åŒ– (ljwx-bigscreen)

#### ä¼˜åŒ–æ–¹æ¡ˆ1: å¢å¼ºæ‰¹å¤„ç†ç³»ç»Ÿ
```python
class EnhancedDeviceBatchProcessor:
    """
    å¢å¼ºçš„è®¾å¤‡æ‰¹å¤„ç†å™¨
    æ”¯æŒä¼˜å…ˆçº§é˜Ÿåˆ—ã€åŠ¨æ€æ‰©å®¹ã€æ•…éšœæ¢å¤
    """
    def __init__(self):
        # æ‰©å¤§é˜Ÿåˆ—å®¹é‡å¹¶åˆ†ä¼˜å…ˆçº§
        self.queues = {
            'urgent': Queue(maxsize=10000),    # ç´§æ€¥æ•°æ®(å‘Šè­¦ã€SOS)
            'normal': Queue(maxsize=30000),    # å¸¸è§„è®¾å¤‡ä¿¡æ¯
            'batch': Queue(maxsize=10000)      # æ‰¹é‡å†å²æ•°æ®
        }
        
        # åˆ†å±‚å·¥ä½œçº¿ç¨‹æ± 
        self.worker_pools = {
            'urgent': ThreadPoolExecutor(max_workers=8, thread_name_prefix='urgent-'),
            'normal': ThreadPoolExecutor(max_workers=12, thread_name_prefix='normal-'), 
            'batch': ThreadPoolExecutor(max_workers=4, thread_name_prefix='batch-')
        }
        
        # å¯åŠ¨ç›‘æ§å’Œæ•…éšœæ¢å¤
        self.start_queue_monitor()
        
    def submit_with_priority(self, device_data, priority='normal'):
        """
        æŒ‰ä¼˜å…ˆçº§æäº¤è®¾å¤‡æ•°æ®
        """
        try:
            queue = self.queues[priority]
            if queue.full():
                # é˜Ÿåˆ—æ»¡æ—¶çš„æ™ºèƒ½å¤„ç†ç­–ç•¥
                if priority == 'urgent':
                    # ç´§æ€¥æ•°æ®ï¼šæŒ¤æ‰æœ€è€çš„normalæ•°æ®
                    self._make_room_for_urgent()
                elif priority == 'normal':
                    # å¸¸è§„æ•°æ®ï¼šè½¬å…¥æ‰¹å¤„ç†é˜Ÿåˆ—
                    self.queues['batch'].put_nowait(device_data)
                    return True
                else:
                    # æ‰¹å¤„ç†æ•°æ®ï¼šä¸¢å¼ƒæœ€è€æ•°æ®
                    try:
                        queue.get_nowait()
                    except:
                        pass
                        
            queue.put_nowait(device_data)
            return True
            
        except Exception as e:
            logger.error(f"æäº¤è®¾å¤‡æ•°æ®å¤±è´¥: {e}")
            return False
    
    def start_processing(self):
        """
        å¯åŠ¨åˆ†å±‚æ•°æ®å¤„ç†
        """
        for priority, pool in self.worker_pools.items():
            for i in range(pool._max_workers):
                pool.submit(self._process_queue, priority)
    
    def _process_queue(self, priority):
        """
        å¤„ç†æŒ‡å®šä¼˜å…ˆçº§é˜Ÿåˆ—çš„æ•°æ®
        """
        queue = self.queues[priority]
        while True:
            try:
                device_data = queue.get(timeout=5)
                self._process_device_data(device_data, priority)
                queue.task_done()
                
                # åŠ¨æ€è°ƒæ•´å¤„ç†é€Ÿåº¦
                if priority == 'urgent':
                    time.sleep(0.01)  # ç´§æ€¥æ•°æ®å¿«é€Ÿå¤„ç†
                elif priority == 'normal':
                    time.sleep(0.1)   # å¸¸è§„æ•°æ®æ­£å¸¸å¤„ç†  
                else:
                    time.sleep(0.5)   # æ‰¹é‡æ•°æ®æ…¢é€Ÿå¤„ç†
                    
            except queue.Empty:
                continue
            except Exception as e:
                logger.error(f"å¤„ç†{priority}é˜Ÿåˆ—æ•°æ®å¤±è´¥: {e}")
```

#### ä¼˜åŒ–æ–¹æ¡ˆ2: Redisç¼“å­˜å±‚ä¼˜åŒ–
```python
class OptimizedDeviceStatusCache:
    """
    ä¼˜åŒ–çš„è®¾å¤‡çŠ¶æ€ç¼“å­˜ç³»ç»Ÿ
    æ”¯æŒæ‰¹é‡æ“ä½œã€æ™ºèƒ½è¿‡æœŸã€çŠ¶æ€é¢„æµ‹
    """
    def __init__(self):
        self.redis_client = redis.Redis(
            connection_pool=redis.ConnectionPool(
                max_connections=50,  # æ‰©å¤§è¿æ¥æ± 
                retry_on_timeout=True
            )
        )
        self.status_ttl = 300  # 5åˆ†é’ŸçŠ¶æ€ç¼“å­˜
        self.batch_size = 1000 # æ‰¹é‡æ“ä½œå¤§å°
        
    def batch_update_device_status(self, device_statuses):
        """
        æ‰¹é‡æ›´æ–°è®¾å¤‡çŠ¶æ€ï¼Œå‡å°‘Rediså¾€è¿”æ¬¡æ•°
        """
        try:
            with self.redis_client.pipeline() as pipe:
                for i, (serial_number, status_data) in enumerate(device_statuses.items()):
                    cache_key = f"device_status:{serial_number}"
                    
                    # è®¾ç½®è®¾å¤‡çŠ¶æ€å’Œè¿‡æœŸæ—¶é—´
                    pipe.hset(cache_key, mapping={
                        'status': status_data.get('status', 'UNKNOWN'),
                        'last_seen': status_data.get('timestamp', int(time.time())),
                        'battery_level': status_data.get('battery_level', 0),
                        'update_time': int(time.time())
                    })
                    pipe.expire(cache_key, self.status_ttl)
                    
                    # åˆ†æ‰¹æ‰§è¡Œï¼Œé¿å…å•æ¬¡æ“ä½œè¿‡å¤§
                    if (i + 1) % self.batch_size == 0:
                        pipe.execute()
                        pipe = self.redis_client.pipeline()
                
                # æ‰§è¡Œå‰©ä½™æ“ä½œ        
                if len(device_statuses) % self.batch_size != 0:
                    pipe.execute()
                    
                logger.info(f"æ‰¹é‡æ›´æ–° {len(device_statuses)} ä¸ªè®¾å¤‡çŠ¶æ€å®Œæˆ")
                return True
                
        except Exception as e:
            logger.error(f"æ‰¹é‡æ›´æ–°è®¾å¤‡çŠ¶æ€å¤±è´¥: {e}")
            return False
    
    def get_device_status_batch(self, serial_numbers):
        """
        æ‰¹é‡è·å–è®¾å¤‡çŠ¶æ€
        """
        try:
            with self.redis_client.pipeline() as pipe:
                for sn in serial_numbers:
                    pipe.hgetall(f"device_status:{sn}")
                
                results = pipe.execute()
                
                # æ„å»ºçŠ¶æ€æ˜ å°„
                status_map = {}
                for i, result in enumerate(results):
                    sn = serial_numbers[i]
                    if result:
                        status_map[sn] = {
                            'status': result.get('status', 'UNKNOWN'),
                            'last_seen': int(result.get('last_seen', 0)),
                            'battery_level': int(result.get('battery_level', 0)),
                            'is_cached': True
                        }
                    else:
                        # ç¼“å­˜æœªå‘½ä¸­ï¼Œæ ‡è®°éœ€è¦æŸ¥è¯¢æ•°æ®åº“
                        status_map[sn] = {'is_cached': False}
                
                return status_map
                
        except Exception as e:
            logger.error(f"æ‰¹é‡è·å–è®¾å¤‡çŠ¶æ€å¤±è´¥: {e}")
            return {}
    
    def smart_status_prediction(self, serial_number, history_data):
        """
        åŸºäºå†å²æ•°æ®çš„è®¾å¤‡çŠ¶æ€æ™ºèƒ½é¢„æµ‹
        """
        try:
            # åˆ†æè®¾å¤‡ä¸ŠæŠ¥æ¨¡å¼
            intervals = []
            for i in range(1, len(history_data)):
                interval = history_data[i]['timestamp'] - history_data[i-1]['timestamp']
                intervals.append(interval)
            
            if intervals:
                avg_interval = sum(intervals) / len(intervals)
                last_seen = history_data[-1]['timestamp']
                expected_next = last_seen + avg_interval
                
                # é¢„æµ‹è®¾å¤‡çŠ¶æ€
                now = time.time()
                if now <= expected_next + 60:  # 1åˆ†é’Ÿå®¹é”™
                    predicted_status = 'ACTIVE'
                else:
                    predicted_status = 'INACTIVE'
                
                # å°†é¢„æµ‹ç»“æœç¼“å­˜
                self.redis_client.hset(
                    f"device_prediction:{serial_number}",
                    mapping={
                        'predicted_status': predicted_status,
                        'confidence': min(0.9, len(intervals) / 10),  # åŸºäºæ•°æ®é‡çš„ç½®ä¿¡åº¦
                        'predicted_at': int(now)
                    }
                )
                
                return predicted_status
                
        except Exception as e:
            logger.error(f"è®¾å¤‡çŠ¶æ€é¢„æµ‹å¤±è´¥: {e}")
            
        return 'UNKNOWN'
```

**é¢„æœŸæ•ˆæœ**:
- è®¾å¤‡å¹¶å‘å¤„ç†èƒ½åŠ›ä»1000/ç§’æå‡è‡³2000/ç§’
- å¹³å‡å¤„ç†å»¶è¿Ÿä»200msé™è‡³50ms  
- æ¶ˆé™¤é˜Ÿåˆ—æ»¡é™çº§é—®é¢˜ï¼Œç³»ç»Ÿç¨³å®šæ€§æå‡95%
- Redisç¼“å­˜å‘½ä¸­ç‡è¾¾åˆ°90%ä»¥ä¸Š

### 4.3 æ•°æ®åº“å±‚ä¼˜åŒ–

#### ä¼˜åŒ–æ–¹æ¡ˆ1: å†å²è¡¨åˆ†åŒºç­–ç•¥
```sql
-- 1. åˆ›å»ºæ–°çš„åˆ†åŒºè¡¨ç»“æ„
CREATE TABLE t_device_info_history_new (
    id BIGINT AUTO_INCREMENT,
    serial_number VARCHAR(64) NOT NULL,
    system_software_version VARCHAR(128),
    battery_level INT,
    wearable_status VARCHAR(32),
    charging_status VARCHAR(32),
    status VARCHAR(32),
    voltage INT,
    timestamp TIMESTAMP NOT NULL,
    customer_id BIGINT NOT NULL,
    is_deleted TINYINT DEFAULT 0,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    PRIMARY KEY (id, timestamp),  -- å¤åˆä¸»é”®åŒ…å«åˆ†åŒºå­—æ®µ
    INDEX idx_serial_timestamp (serial_number, timestamp DESC),
    INDEX idx_customer_serial (customer_id, serial_number),
    INDEX idx_status_check (serial_number, timestamp DESC, is_deleted)
) ENGINE=InnoDB
PARTITION BY RANGE (YEAR(timestamp) * 100 + MONTH(timestamp)) (
    PARTITION p202501 VALUES LESS THAN (202502),
    PARTITION p202502 VALUES LESS THAN (202503),
    PARTITION p202503 VALUES LESS THAN (202504),
    PARTITION p202504 VALUES LESS THAN (202505),
    PARTITION p202505 VALUES LESS THAN (202506),
    PARTITION p202506 VALUES LESS THAN (202507),
    PARTITION p202507 VALUES LESS THAN (202508),
    PARTITION p202508 VALUES LESS THAN (202509),
    PARTITION p202509 VALUES LESS THAN (202510),
    PARTITION p202510 VALUES LESS THAN (202511),
    PARTITION p202511 VALUES LESS THAN (202512),
    PARTITION p202512 VALUES LESS THAN (202513),
    -- ä¸ºæœªæ¥12ä¸ªæœˆé¢„åˆ›å»ºåˆ†åŒº
    PARTITION p202601 VALUES LESS THAN (202602),
    PARTITION p202602 VALUES LESS THAN (202603),
    PARTITION p202603 VALUES LESS THAN (202604),
    PARTITION p202604 VALUES LESS THAN (202605),
    PARTITION p202605 VALUES LESS THAN (202606),
    PARTITION p202606 VALUES LESS THAN (202607),
    PARTITION p202607 VALUES LESS THAN (202608),
    PARTITION p202608 VALUES LESS THAN (202609),
    PARTITION p202609 VALUES LESS THAN (202610),
    PARTITION p202610 VALUES LESS THAN (202611),
    PARTITION p202611 VALUES LESS THAN (202612),
    PARTITION p202612 VALUES LESS THAN (202613),
    -- å…œåº•åˆ†åŒº
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- 2. åˆ›å»ºåˆ†åŒºç®¡ç†å­˜å‚¨è¿‡ç¨‹
DELIMITER //
CREATE PROCEDURE ManageHistoryPartitions()
BEGIN
    DECLARE partition_name VARCHAR(20);
    DECLARE partition_value INT;
    DECLARE current_month INT;
    DECLARE next_month INT;
    DECLARE done INT DEFAULT FALSE;
    
    -- è·å–å½“å‰æœˆä»½
    SET current_month = YEAR(CURDATE()) * 100 + MONTH(CURDATE());
    SET next_month = IF(MONTH(CURDATE()) = 12, 
                       (YEAR(CURDATE()) + 1) * 100 + 1, 
                       current_month + 1);
    
    -- åˆ›å»ºä¸‹ä¸ªæœˆçš„åˆ†åŒº
    SET partition_name = CONCAT('p', next_month);
    SET partition_value = next_month + 1;
    
    SET @sql = CONCAT('ALTER TABLE t_device_info_history_new ADD PARTITION (PARTITION ', 
                     partition_name, ' VALUES LESS THAN (', partition_value, '))');
    
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- åˆ é™¤6ä¸ªæœˆå‰çš„åˆ†åŒº (ä¿ç•™6ä¸ªæœˆå†å²æ•°æ®)
    SET partition_name = CONCAT('p', current_month - 6);
    
    SET @sql = CONCAT('ALTER TABLE t_device_info_history_new DROP PARTITION ', partition_name);
    
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
END //
DELIMITER ;

-- 3. åˆ›å»ºå®šæ—¶ä»»åŠ¡ï¼Œæ¯æœˆè‡ªåŠ¨ç®¡ç†åˆ†åŒº
CREATE EVENT IF NOT EXISTS AutoManagePartitions
ON SCHEDULE EVERY 1 MONTH
STARTS '2025-02-01 02:00:00'
DO CALL ManageHistoryPartitions();
```

#### ä¼˜åŒ–æ–¹æ¡ˆ2: ç´¢å¼•ç­–ç•¥ä¼˜åŒ–
```sql
-- 1. è®¾å¤‡ä¿¡æ¯è¡¨ä¼˜åŒ–ç´¢å¼•
ALTER TABLE t_device_info 
ADD INDEX idx_device_user_binding (customer_id, serial_number, is_deleted),
ADD INDEX idx_device_status_query (serial_number, update_time DESC),
ADD INDEX idx_org_device_mapping (customer_id, is_deleted, update_time DESC);

-- 2. å†å²è¡¨æŸ¥è¯¢ä¼˜åŒ–ç´¢å¼• 
ALTER TABLE t_device_info_history_new
ADD INDEX idx_realtime_status (serial_number, timestamp DESC, is_deleted),
ADD INDEX idx_batch_status_check (customer_id, timestamp DESC),
ADD INDEX idx_device_trend_analysis (serial_number, timestamp, battery_level, wearable_status);

-- 3. åˆ›å»ºç‰©åŒ–è§†å›¾ä¼˜åŒ–é¢‘ç¹æŸ¥è¯¢
CREATE VIEW v_device_latest_status AS
SELECT 
    di.serial_number,
    di.customer_id,
    di.battery_level,
    di.wearable_status,
    di.charging_status,
    di.system_software_version,
    di.update_time,
    CASE 
        WHEN di.update_time >= DATE_SUB(NOW(), INTERVAL 5 MINUTE) 
        THEN 'ACTIVE'
        ELSE 'INACTIVE'
    END as real_status,
    ui.user_name,
    oi.name as org_name
FROM t_device_info di
LEFT JOIN sys_user ui ON ui.device_sn = di.serial_number AND ui.is_deleted = 0
LEFT JOIN sys_user_org suo ON ui.id = suo.user_id AND suo.is_deleted = 0  
LEFT JOIN sys_org_units oi ON suo.org_id = oi.id AND oi.is_deleted = 0
WHERE di.is_deleted = 0;
```

#### ä¼˜åŒ–æ–¹æ¡ˆ3: æŸ¥è¯¢è¯­å¥ä¼˜åŒ–
```sql
-- ä¼˜åŒ–å‰ï¼šä½æ•ˆçš„è®¾å¤‡çŠ¶æ€æŸ¥è¯¢
SELECT d.*, 
       (SELECT COUNT(*) FROM t_device_info_history h 
        WHERE h.serial_number = d.serial_number 
        AND h.timestamp >= DATE_SUB(NOW(), INTERVAL 5 MINUTE)) as is_active
FROM t_device_info d 
WHERE d.customer_id = ? 
ORDER BY d.update_time DESC;

-- ä¼˜åŒ–åï¼šä½¿ç”¨JOINå’Œç´¢å¼•ä¼˜åŒ–
SELECT DISTINCT
    d.serial_number,
    d.customer_id, 
    d.battery_level,
    d.wearable_status,
    d.charging_status,
    d.update_time,
    CASE WHEN h.latest_timestamp IS NOT NULL THEN 'ACTIVE' ELSE 'INACTIVE' END as status
FROM t_device_info d
LEFT JOIN (
    SELECT serial_number, MAX(timestamp) as latest_timestamp
    FROM t_device_info_history_new
    WHERE timestamp >= DATE_SUB(NOW(), INTERVAL 5 MINUTE)
    AND is_deleted = 0
    GROUP BY serial_number
) h ON d.serial_number = h.serial_number
WHERE d.customer_id = ?
AND d.is_deleted = 0
ORDER BY d.update_time DESC;

-- æ‰¹é‡è®¾å¤‡çŠ¶æ€æŸ¥è¯¢ä¼˜åŒ–
SELECT 
    serial_number,
    MAX(timestamp) as last_seen,
    MAX(CASE WHEN timestamp >= DATE_SUB(NOW(), INTERVAL 5 MINUTE) THEN 1 ELSE 0 END) as is_active
FROM t_device_info_history_new 
WHERE serial_number IN (?, ?, ?, ...) 
AND is_deleted = 0
AND timestamp >= DATE_SUB(NOW(), INTERVAL 1 HOUR)  -- é™åˆ¶æŸ¥è¯¢èŒƒå›´
GROUP BY serial_number;
```

**é¢„æœŸæ•ˆæœ**:
- å†å²è¡¨æŸ¥è¯¢æ€§èƒ½æå‡80%
- å­˜å‚¨ç©ºé—´èŠ‚çœ60% (è‡ªåŠ¨æ¸…ç†6ä¸ªæœˆå‰æ•°æ®)
- è®¾å¤‡çŠ¶æ€æŸ¥è¯¢å»¶è¿Ÿä»2ç§’é™è‡³200ms
- æ”¯æŒåƒä¸‡çº§å†å²æ•°æ®é«˜æ•ˆæŸ¥è¯¢

### 4.4 æœåŠ¡å±‚ä¼˜åŒ– (ljwx-boot)

#### ä¼˜åŒ–æ–¹æ¡ˆ1: ç¼“å­˜ç­–ç•¥ä¼˜åŒ–
```java
/**
 * ä¼˜åŒ–çš„è®¾å¤‡ä¿¡æ¯æœåŠ¡
 * æ”¯æŒå¤šçº§ç¼“å­˜ã€æ‰¹é‡æŸ¥è¯¢ã€å¼‚æ­¥å¤„ç†
 */
@Service
public class OptimizedTDeviceInfoService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired  
    private TDeviceInfoMapper deviceInfoMapper;
    
    // L1ç¼“å­˜ï¼šJVMæœ¬åœ°ç¼“å­˜ (çƒ­ç‚¹æ•°æ®)
    @Cacheable(value = "deviceInfo", key = "'device:' + #serialNumber")
    public DeviceInfo getDeviceInfo(String serialNumber) {
        return deviceInfoMapper.selectBySerialNumber(serialNumber);
    }
    
    // L2ç¼“å­˜ï¼šRedisåˆ†å¸ƒå¼ç¼“å­˜
    public DeviceUserMapping getDeviceUserMapping(String serialNumber) {
        String cacheKey = "device_user:" + serialNumber;
        
        // å…ˆæŸ¥Redisç¼“å­˜
        DeviceUserMapping cached = (DeviceUserMapping) redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }
        
        // ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥è¯¢æ•°æ®åº“
        DeviceUserMapping mapping = deviceInfoMapper.selectDeviceUserMapping(serialNumber);
        if (mapping != null) {
            // ç¼“å­˜10åˆ†é’Ÿ
            redisTemplate.opsForValue().set(cacheKey, mapping, Duration.ofMinutes(10));
        }
        
        return mapping;
    }
    
    /**
     * æ‰¹é‡è·å–è®¾å¤‡ç”¨æˆ·æ˜ å°„å…³ç³»
     * ä¼˜åŒ–N+1æŸ¥è¯¢é—®é¢˜
     */
    public Map<String, DeviceUserMapping> batchGetDeviceUserMapping(List<String> serialNumbers) {
        Map<String, DeviceUserMapping> result = new HashMap<>();
        List<String> uncachedSerialNumbers = new ArrayList<>();
        
        // æ‰¹é‡æŸ¥è¯¢Redisç¼“å­˜
        List<String> cacheKeys = serialNumbers.stream()
            .map(sn -> "device_user:" + sn)
            .collect(Collectors.toList());
            
        List<DeviceUserMapping> cachedMappings = redisTemplate.opsForValue().multiGet(cacheKeys);
        
        for (int i = 0; i < serialNumbers.size(); i++) {
            String serialNumber = serialNumbers.get(i);
            DeviceUserMapping cached = cachedMappings.get(i);
            
            if (cached != null) {
                result.put(serialNumber, cached);
            } else {
                uncachedSerialNumbers.add(serialNumber);
            }
        }
        
        // æ‰¹é‡æŸ¥è¯¢æœªç¼“å­˜çš„æ•°æ®
        if (!uncachedSerialNumbers.isEmpty()) {
            List<DeviceUserMapping> uncachedMappings = deviceInfoMapper
                .selectDeviceUserMappingBatch(uncachedSerialNumbers);
            
            // æ‰¹é‡å†™å…¥ç¼“å­˜
            Map<String, DeviceUserMapping> cacheMap = new HashMap<>();
            for (DeviceUserMapping mapping : uncachedMappings) {
                result.put(mapping.getSerialNumber(), mapping);
                cacheMap.put("device_user:" + mapping.getSerialNumber(), mapping);
            }
            
            if (!cacheMap.isEmpty()) {
                redisTemplate.opsForValue().multiSet(cacheMap);
                // è®¾ç½®è¿‡æœŸæ—¶é—´
                cacheMap.keySet().forEach(key -> 
                    redisTemplate.expire(key, Duration.ofMinutes(10)));
            }
        }
        
        return result;
    }
    
    /**
     * å¼‚æ­¥æ›´æ–°è®¾å¤‡çŠ¶æ€
     * é¿å…é˜»å¡ä¸»çº¿ç¨‹
     */
    @Async("deviceStatusExecutor")
    public CompletableFuture<Void> asyncUpdateDeviceStatus(List<DeviceStatusUpdate> updates) {
        try {
            // æ‰¹é‡æ›´æ–°æ•°æ®åº“
            deviceInfoMapper.batchUpdateStatus(updates);
            
            // æ‰¹é‡æ›´æ–°ç¼“å­˜
            Map<String, Object> cacheUpdates = updates.stream()
                .collect(Collectors.toMap(
                    update -> "device_info:" + update.getSerialNumber(),
                    update -> update.getDeviceInfo()
                ));
            
            redisTemplate.opsForValue().multiSet(cacheUpdates);
            
            log.info("å¼‚æ­¥æ›´æ–° {} ä¸ªè®¾å¤‡çŠ¶æ€å®Œæˆ", updates.size());
            
        } catch (Exception e) {
            log.error("å¼‚æ­¥æ›´æ–°è®¾å¤‡çŠ¶æ€å¤±è´¥", e);
        }
        
        return CompletableFuture.completedFuture(null);
    }
}
```

#### ä¼˜åŒ–æ–¹æ¡ˆ2: æ¸¸æ ‡åˆ†é¡µä¼˜åŒ–
```java
/**
 * æ¸¸æ ‡åˆ†é¡µæœåŠ¡
 * è§£å†³æ·±åˆ†é¡µæ€§èƒ½é—®é¢˜
 */
@Service
public class CursorPaginationService {
    
    /**
     * åŸºäºæ¸¸æ ‡çš„è®¾å¤‡ä¿¡æ¯åˆ†é¡µæŸ¥è¯¢
     * æ€§èƒ½ä¸éšé¡µæ•°å¢åŠ è€Œä¸‹é™
     */
    public PageResult<DeviceInfo> getDevicesByCursor(
            String cursor, int pageSize, Long customerId) {
        
        QueryWrapper<TDeviceInfo> queryWrapper = new QueryWrapper<TDeviceInfo>()
            .eq("customer_id", customerId)
            .eq("is_deleted", 0);
        
        // ä½¿ç”¨æ¸¸æ ‡æ¡ä»¶
        if (StringUtils.hasText(cursor)) {
            try {
                Long cursorId = Long.parseLong(cursor);
                queryWrapper.lt("id", cursorId);  // id < cursor
            } catch (NumberFormatException e) {
                log.warn("æ— æ•ˆçš„æ¸¸æ ‡å€¼: {}", cursor);
            }
        }
        
        // æŒ‰IDé™åºæ’åˆ—ï¼Œå–pageSize+1æ¡è®°å½•
        List<TDeviceInfo> devices = deviceInfoMapper.selectList(
            queryWrapper.orderByDesc("id").last("LIMIT " + (pageSize + 1))
        );
        
        // åˆ¤æ–­æ˜¯å¦æœ‰ä¸‹ä¸€é¡µ
        boolean hasNext = devices.size() > pageSize;
        if (hasNext) {
            devices.remove(devices.size() - 1);  // ç§»é™¤å¤šæŸ¥çš„ä¸€æ¡
        }
        
        // ç”Ÿæˆä¸‹ä¸€é¡µæ¸¸æ ‡
        String nextCursor = null;
        if (hasNext && !devices.isEmpty()) {
            nextCursor = devices.get(devices.size() - 1).getId().toString();
        }
        
        return PageResult.<DeviceInfo>builder()
            .data(convertToDeviceInfoList(devices))
            .pageSize(pageSize)
            .hasNext(hasNext)
            .nextCursor(nextCursor)
            .build();
    }
    
    /**
     * åŸºäºæ—¶é—´æ¸¸æ ‡çš„è®¾å¤‡å†å²æŸ¥è¯¢
     * é€‚ç”¨äºæ—¶åºæ•°æ®åˆ†é¡µ
     */
    public TimeBasedPageResult<DeviceHistoryInfo> getDeviceHistoryByCursor(
            String serialNumber, String timeCursor, int pageSize) {
        
        QueryWrapper<TDeviceInfoHistory> queryWrapper = new QueryWrapper<TDeviceInfoHistory>()
            .eq("serial_number", serialNumber)
            .eq("is_deleted", 0);
        
        // ä½¿ç”¨æ—¶é—´æ¸¸æ ‡
        if (StringUtils.hasText(timeCursor)) {
            try {
                LocalDateTime cursorTime = LocalDateTime.parse(
                    timeCursor, DateTimeFormatter.ISO_LOCAL_DATE_TIME);
                queryWrapper.lt("timestamp", cursorTime);
            } catch (Exception e) {
                log.warn("æ— æ•ˆçš„æ—¶é—´æ¸¸æ ‡: {}", timeCursor);
            }
        }
        
        List<TDeviceInfoHistory> history = deviceHistoryMapper.selectList(
            queryWrapper.orderByDesc("timestamp").last("LIMIT " + (pageSize + 1))
        );
        
        boolean hasNext = history.size() > pageSize;
        if (hasNext) {
            history.remove(history.size() - 1);
        }
        
        String nextCursor = null;
        if (hasNext && !history.isEmpty()) {
            nextCursor = history.get(history.size() - 1).getTimestamp()
                .format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        }
        
        return TimeBasedPageResult.<DeviceHistoryInfo>builder()
            .data(convertToHistoryInfoList(history))
            .pageSize(pageSize)
            .hasNext(hasNext)
            .nextTimeCursor(nextCursor)
            .build();
    }
}
```

#### ä¼˜åŒ–æ–¹æ¡ˆ3: æ•°æ®åº“è¿æ¥æ± ä¼˜åŒ–
```yaml
# application.yml - æ•°æ®åº“è¿æ¥æ± ä¼˜åŒ–é…ç½®
spring:
  datasource:
    type: com.zaxxer.hikari.HikariDataSource
    hikari:
      # è¿æ¥æ± å¤§å°ä¼˜åŒ–
      minimum-idle: 10          # æœ€å°ç©ºé—²è¿æ¥
      maximum-pool-size: 50     # æœ€å¤§è¿æ¥æ± å¤§å°
      idle-timeout: 300000      # ç©ºé—²è¿æ¥è¶…æ—¶æ—¶é—´(5åˆ†é’Ÿ)
      connection-timeout: 20000 # è¿æ¥è¶…æ—¶æ—¶é—´(20ç§’)
      max-lifetime: 1800000     # è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ(30åˆ†é’Ÿ)
      
      # è¿æ¥æ£€æµ‹ä¼˜åŒ–
      connection-test-query: SELECT 1
      validation-timeout: 5000
      
      # è¿æ¥æ³„éœ²æ£€æµ‹
      leak-detection-threshold: 60000  # 60ç§’æ£€æµ‹è¿æ¥æ³„éœ²
      
      # è¿æ¥æ± ç›‘æ§
      register-mbeans: true
      
  # MyBatisé…ç½®ä¼˜åŒ–  
  mybatis-plus:
    configuration:
      # å¼€å¯äºŒçº§ç¼“å­˜
      cache-enabled: true
      # å¼€å¯æ‡’åŠ è½½
      lazy-loading-enabled: true
      aggressive-lazy-loading: false
      # æ‰¹é‡æ‰§è¡Œä¼˜åŒ–
      default-executor-type: BATCH
      # ç»“æœé›†å¤§å°é™åˆ¶
      default-fetch-size: 1000
      
    # åˆ†é¡µæ’ä»¶ä¼˜åŒ–
    plugins:
      - type: com.baomidou.mybatisplus.extension.plugins.PaginationInnerInterceptor
        properties:
          overflow: true          # æº¢å‡ºæ€»é¡µæ•°åæ˜¯å¦è¿›è¡Œå¤„ç†
          max-limit: 1000         # å•é¡µåˆ†é¡µæ¡æ•°é™åˆ¶
          optimize-join-sql: true # ä¼˜åŒ–JOINæŸ¥è¯¢
```

**é¢„æœŸæ•ˆæœ**:
- æ•°æ®åº“æŸ¥è¯¢æ€§èƒ½æå‡70%
- ç¼“å­˜å‘½ä¸­ç‡è¾¾åˆ°85%ä»¥ä¸Š  
- åˆ†é¡µæŸ¥è¯¢æ€§èƒ½æå‡90% (æ¸¸æ ‡åˆ†é¡µ)
- è¿æ¥æ± åˆ©ç”¨ç‡æå‡è‡³80%ï¼Œè¿æ¥æ³„éœ²ç‡é™è‡³0
- è®¾å¤‡ç»‘å®š/è§£ç»‘æ“ä½œæ€§èƒ½æå‡60%
- å¤šç§Ÿæˆ·æŸ¥è¯¢å“åº”æ—¶é—´é™ä½80%

## 5. æ•´ä½“ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–æ•ˆæœé¢„æµ‹

### 5.1 æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| ä¼˜åŒ–é¡¹ç›® | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æå‡å¹…åº¦ |
|---------|--------|--------|----------|
| **æ•°æ®é‡‡é›†å±‚** | | | |
| è®¾å¤‡ç”µæ± ç»­èˆª | 12å°æ—¶ | 18å°æ—¶ | +50% |
| **è®¾å¤‡ç»‘å®š/è§£ç»‘ä¼˜åŒ–** | | | |
| å•è®¾å¤‡ç»‘å®šæ—¶é—´ | 500ms | 200ms | -60% |
| æ‰¹é‡ç»‘å®šæ€§èƒ½ | 5è®¾å¤‡/ç§’ | 20è®¾å¤‡/ç§’ | +300% |
| ç»‘å®šç¼“å­˜å‘½ä¸­ç‡ | 30% | 90% | +200% |
| **å¤šç§Ÿæˆ·æŸ¥è¯¢ä¼˜åŒ–** | | | |
| customerIdæŸ¥è¯¢æ—¶é—´ | 800ms | 160ms | -80% |
| orgId+userIdæŸ¥è¯¢æ—¶é—´ | 1200ms | 200ms | -83% |
| è®¾å¤‡çŠ¶æ€æ‰¹é‡æ£€æŸ¥ | 2000ms | 300ms | -85% |
| CPUä½¿ç”¨ç‡(é‡‡é›†æ—¶) | 60% | 24% | -60% |
| æ•°æ®é‡‡é›†å¹¶å‘æ•° | å•çº¿ç¨‹è½®è¯¢ | 5çº¿ç¨‹å¹¶è¡Œ | +400% |
| **æ‰¹å¤„ç†å±‚** | | | |
| è®¾å¤‡å¹¶å‘å¤„ç† | 1000è®¾å¤‡/ç§’ | 2000è®¾å¤‡/ç§’ | +100% |
| å¹³å‡å¤„ç†å»¶è¿Ÿ | 200ms | 50ms | -75% |
| é˜Ÿåˆ—å®¹é‡ | 10000 | 50000 | +400% |
| Redisç¼“å­˜å‘½ä¸­ç‡ | 60% | 90% | +50% |
| **æ•°æ®åº“å±‚** | | | |
| å†å²è¡¨æŸ¥è¯¢æ—¶é—´ | 2000ms | 400ms | -80% |
| è®¾å¤‡çŠ¶æ€æŸ¥è¯¢ | 500ms | 100ms | -80% |
| å­˜å‚¨ç©ºé—´å ç”¨ | æ— é™å¢é•¿ | è‡ªåŠ¨æ¸…ç† | -60% |
| å¹¶å‘æŸ¥è¯¢æ”¯æŒ | 100 QPS | 300 QPS | +200% |
| **æœåŠ¡å±‚** | | | |
| APIå“åº”æ—¶é—´ | 800ms | 200ms | -75% |
| ç¼“å­˜å‘½ä¸­ç‡ | 40% | 85% | +112% |
| åˆ†é¡µæŸ¥è¯¢æ€§èƒ½ | çº¿æ€§ä¸‹é™ | æ’å®šæ—¶é—´ | +90% |
| æ•°æ®åº“è¿æ¥åˆ©ç”¨ç‡ | 40% | 80% | +100% |

### 5.2 æ•´ä½“ç³»ç»Ÿæ•ˆæœ

#### 5.2.1 ç«¯åˆ°ç«¯æ€§èƒ½æå‡
- **æ•°æ®æµå»¶è¿Ÿ**: è®¾å¤‡é‡‡é›† â†’ å‰ç«¯æ˜¾ç¤ºæ€»å»¶è¿Ÿä»30ç§’é™è‡³10ç§’
- **ç³»ç»Ÿåå**: æ•´ä½“å¤„ç†èƒ½åŠ›æå‡150%  
- **ç”¨æˆ·ä½“éªŒ**: ç•Œé¢å“åº”é€Ÿåº¦æå‡75%ï¼Œæ•°æ®å®æ—¶æ€§æ˜¾è‘—æ”¹å–„

#### 5.2.2 èµ„æºåˆ©ç”¨ä¼˜åŒ–
- **CPUä½¿ç”¨ç‡**: å¹³å‡é™ä½40%ï¼Œå³°å€¼é™ä½60%
- **å†…å­˜ä½¿ç”¨ç‡**: é™ä½30%ï¼ŒGCé¢‘ç‡å‡å°‘50%
- **å­˜å‚¨æˆæœ¬**: é™ä½60%ï¼Œç£ç›˜I/Oå‡å°‘70%
- **ç½‘ç»œå¸¦å®½**: æ‰¹é‡ä¼ è¾“ä¼˜åŒ–ï¼Œå¸¦å®½åˆ©ç”¨ç‡æå‡80%

#### 5.2.3 ç³»ç»Ÿç¨³å®šæ€§æå‡
- **ç³»ç»Ÿå¯ç”¨æ€§**: ä»95%æå‡è‡³99.5%
- **æ•…éšœæ¢å¤æ—¶é—´**: ä»5åˆ†é’Ÿé™è‡³1åˆ†é’Ÿ
- **æ•°æ®ä¸€è‡´æ€§**: 99.99%æ•°æ®å®Œæ•´æ€§ä¿è¯
- **æ‰©å±•æ€§**: æ”¯æŒè®¾å¤‡è§„æ¨¡ä»1ä¸‡æ‰©å±•è‡³10ä¸‡

## 6. å®æ–½è®¡åˆ’ä¸é£é™©æ§åˆ¶

### 6.1 åˆ†é˜¶æ®µå®æ–½è®¡åˆ’

#### ç¬¬ä¸€é˜¶æ®µ (1-2å‘¨): æ•°æ®åº“å±‚ä¼˜åŒ–
**ä¼˜å…ˆçº§**: é«˜ (åŸºç¡€è®¾æ–½)
**å®æ–½å†…å®¹**:
1. åˆ›å»ºåˆ†åŒºå†å²è¡¨å¹¶è¿ç§»æ•°æ®
2. æ·»åŠ æ€§èƒ½ä¼˜åŒ–ç´¢å¼•
3. å®æ–½åˆ†åŒºè‡ªåŠ¨ç®¡ç†

**é£é™©æ§åˆ¶**:
- åœ¨æµ‹è¯•ç¯å¢ƒå……åˆ†éªŒè¯åˆ†åŒºç­–ç•¥
- å‡†å¤‡æ•°æ®å›æ»šæ–¹æ¡ˆ
- åˆ†æ‰¹è¿ç§»å†å²æ•°æ®ï¼Œé¿å…é•¿æ—¶é—´é”è¡¨

#### ç¬¬äºŒé˜¶æ®µ (2-3å‘¨): ç¼“å­˜å±‚ä¸æ‰¹å¤„ç†ä¼˜åŒ–
**ä¼˜å…ˆçº§**: é«˜ (æ€§èƒ½æ ¸å¿ƒ)
**å®æ–½å†…å®¹**:
1. éƒ¨ç½²å¢å¼ºç‰ˆæ‰¹å¤„ç†ç³»ç»Ÿ
2. å®æ–½Redisç¼“å­˜ä¼˜åŒ–ç­–ç•¥
3. å¼€å‘è®¾å¤‡çŠ¶æ€é¢„æµ‹åŠŸèƒ½

**é£é™©æ§åˆ¶**:
- ç°åº¦å‘å¸ƒï¼Œé€æ­¥åˆ‡æ¢åˆ°æ–°æ‰¹å¤„ç†ç³»ç»Ÿ
- ä¿æŒåŸæœ‰ç³»ç»Ÿä½œä¸ºå¤‡ä»½ï¼Œç¡®ä¿å¹³æ»‘è¿‡æ¸¡
- ç›‘æ§ç¼“å­˜å‘½ä¸­ç‡å’Œç³»ç»Ÿè´Ÿè½½

#### ç¬¬ä¸‰é˜¶æ®µ (2-3å‘¨): æœåŠ¡å±‚ä¼˜åŒ–
**ä¼˜å…ˆçº§**: ä¸­é«˜ (ç”¨æˆ·ä½“éªŒ)  
**å®æ–½å†…å®¹**:
1. å®æ–½å¤šçº§ç¼“å­˜ç­–ç•¥
2. å‡çº§ä¸ºæ¸¸æ ‡åˆ†é¡µ
3. ä¼˜åŒ–æ•°æ®åº“è¿æ¥æ± é…ç½®

**é£é™©æ§åˆ¶**:
- A/Bæµ‹è¯•å¯¹æ¯”æ–°æ—§åˆ†é¡µæ€§èƒ½
- ç›‘æ§ç¼“å­˜ä¸€è‡´æ€§ï¼Œé˜²æ­¢è„æ•°æ®
- é€æ­¥è°ƒæ•´è¿æ¥æ± å‚æ•°ï¼Œé¿å…è¿æ¥é£æš´

#### ç¬¬å››é˜¶æ®µ (3-4å‘¨): æ•°æ®é‡‡é›†å±‚ä¼˜åŒ–
**ä¼˜å…ˆçº§**: ä¸­ (è®¾å¤‡ç«¯å½±å“å¤§)
**å®æ–½å†…å®¹**:  
1. å¼€å‘æ™ºèƒ½é‡‡é›†è°ƒåº¦å™¨
2. å®æ–½çœç”µä¼˜åŒ–ç­–ç•¥
3. éƒ¨ç½²æ‰¹é‡æ•°æ®ä¸Šä¼ 

**é£é™©æ§åˆ¶**:
- å°èŒƒå›´è®¾å¤‡è¯•ç‚¹ï¼ŒéªŒè¯ç¨³å®šæ€§
- ä¿ç•™åŸæœ‰é‡‡é›†æ–¹æ¡ˆä½œä¸ºé™çº§é€‰é¡¹
- å¯†åˆ‡ç›‘æ§è®¾å¤‡ç”µæ± æ¶ˆè€—å’Œæ•°æ®è´¨é‡

#### ç¬¬äº”é˜¶æ®µ (1-2å‘¨): è®¾å¤‡ç»‘å®š/è§£ç»‘ä¼˜åŒ–
**ä¼˜å…ˆçº§**: é«˜ (ç”¨æˆ·ä½“éªŒå…³é”®)
**å®æ–½å†…å®¹**:
1. å®æ–½ä¼˜åŒ–çš„è®¾å¤‡ç»‘å®š/è§£ç»‘æœåŠ¡
2. éƒ¨ç½²å¤šçº§ç¼“å­˜ç­–ç•¥
3. å®ç°å¼‚æ­¥ç¼“å­˜æ›´æ–°æœºåˆ¶

**é£é™©æ§åˆ¶**:
- ä¿ç•™åŸæœ‰ç»‘å®šé€»è¾‘ä½œä¸ºé™çº§æ–¹æ¡ˆ
- å®æ—¶ç›‘æ§ç»‘å®šæˆåŠŸç‡å’Œå“åº”æ—¶é—´
- éªŒè¯ç¼“å­˜ä¸€è‡´æ€§å’Œæ•°æ®å‡†ç¡®æ€§

### 6.2 ç›‘æ§ä¸å›æ»šç­–ç•¥

#### å…³é”®ç›‘æ§æŒ‡æ ‡
```yaml
# ç›‘æ§é…ç½®
monitoring:
  # æ€§èƒ½ç›‘æ§
  performance:
    - api_response_time_p95 < 500ms
    - database_query_time_p95 < 200ms
    - redis_hit_rate > 85%
    - device_bind_success_rate > 99%
    - tenant_query_time_p95 < 300ms
    - batch_processing_delay < 100ms
    
  # ç¨³å®šæ€§ç›‘æ§  
  stability:
    - error_rate < 0.1%
    - system_availability > 99.5%
    - queue_overflow_rate < 0.01%
    - connection_leak_count = 0
    
  # èµ„æºç›‘æ§
  resources:
    - cpu_usage_avg < 70%
    - memory_usage_avg < 80%
    - disk_usage_growth < 10GB/day
    - connection_pool_usage < 85%
```

#### è‡ªåŠ¨å›æ»šè§¦å‘æ¡ä»¶
- APIé”™è¯¯ç‡è¶…è¿‡1%æŒç»­5åˆ†é’Ÿ
- æ•°æ®åº“æŸ¥è¯¢å¹³å‡æ—¶é—´è¶…è¿‡ä¼˜åŒ–å‰æ°´å¹³
- ç¼“å­˜æœåŠ¡ä¸å¯ç”¨è¶…è¿‡30ç§’
- è®¾å¤‡æ•°æ®ä¸¢å¤±ç‡è¶…è¿‡0.01%

### 6.3 å›¢é˜Ÿåä½œä¸çŸ¥è¯†è½¬ç§»

#### å¼€å‘å›¢é˜Ÿåˆ†å·¥
- **æ•°æ®åº“ä¼˜åŒ–**: DBA + åç«¯å¼€å‘ (2äºº)
- **æ‰¹å¤„ç†ä¼˜åŒ–**: Pythonå¼€å‘ + è¿ç»´ (2äºº)  
- **æœåŠ¡å±‚ä¼˜åŒ–**: Javaåç«¯å¼€å‘ (2äºº)
- **è®¾å¤‡ç«¯ä¼˜åŒ–**: åµŒå…¥å¼å¼€å‘ (1äºº)
- **æµ‹è¯•éªŒè¯**: æµ‹è¯•å·¥ç¨‹å¸ˆ (1äºº)

#### çŸ¥è¯†æ–‡æ¡£è¾“å‡º
1. **æŠ€æœ¯æ–¹æ¡ˆæ–‡æ¡£**: è¯¦ç»†çš„å®æ–½æ­¥éª¤å’Œé…ç½®å‚æ•°
2. **è¿ç»´æ‰‹å†Œ**: ç›‘æ§æŒ‡æ ‡ã€æ•…éšœæ’æŸ¥ã€åº”æ€¥é¢„æ¡ˆ
3. **å¼€å‘è§„èŒƒ**: ä»£ç è§„èŒƒã€æ€§èƒ½æœ€ä½³å®è·µ
4. **æµ‹è¯•ç”¨ä¾‹**: æ€§èƒ½æµ‹è¯•ã€å‹åŠ›æµ‹è¯•ã€å›å½’æµ‹è¯•

## 7. æ€»ç»“ä¸åç»­è§„åˆ’

### 7.1 ä¼˜åŒ–æ–¹æ¡ˆæ€»ç»“

æœ¬è®¾å¤‡ç®¡ç†ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆä»**æ•°æ®é‡‡é›†ã€æ‰¹å¤„ç†ã€å­˜å‚¨ã€æœåŠ¡ã€å±•ç¤º**äº”ä¸ªå±‚é¢è¿›è¡Œå…¨æ–¹ä½ä¼˜åŒ–ï¼š

1. **æ•°æ®é‡‡é›†å±‚**: åˆ†å±‚æ™ºèƒ½è°ƒåº¦ + çœç”µä¼˜åŒ–ï¼Œç”µæ± ç»­èˆªæå‡50%
2. **æ‰¹å¤„ç†å±‚**: ä¼˜å…ˆçº§é˜Ÿåˆ— + ç¼“å­˜ä¼˜åŒ–ï¼Œå¤„ç†èƒ½åŠ›æå‡100%  
3. **å­˜å‚¨å±‚**: åˆ†åŒºç­–ç•¥ + ç´¢å¼•ä¼˜åŒ–ï¼ŒæŸ¥è¯¢æ€§èƒ½æå‡80%
4. **æœåŠ¡å±‚**: å¤šçº§ç¼“å­˜ + æ¸¸æ ‡åˆ†é¡µï¼Œå“åº”æ—¶é—´é™ä½75%
5. **è®¾å¤‡ç»‘å®šç®¡ç†**: æ‰¹é‡æ“ä½œ + å¼‚æ­¥ç¼“å­˜ï¼Œç»‘å®šæ€§èƒ½æå‡300%
6. **å¤šç§Ÿæˆ·æŸ¥è¯¢**: ç´¢å¼•ä¼˜åŒ– + åˆ†ç‰‡ç­–ç•¥ï¼ŒæŸ¥è¯¢æ—¶é—´é™ä½80%
7. **æ•´ä½“ç³»ç»Ÿ**: ç«¯åˆ°ç«¯å»¶è¿Ÿé™ä½67%ï¼Œèµ„æºåˆ©ç”¨ç‡æå‡40%

### 7.2 æŠ€æœ¯åˆ›æ–°ç‚¹

1. **æ™ºèƒ½åˆ†å±‚è°ƒåº¦**: æ ¹æ®æ•°æ®é‡è¦æ€§å’Œè®¾å¤‡çŠ¶æ€åŠ¨æ€è°ƒåº¦é‡‡é›†ç­–ç•¥
2. **é¢„æµ‹æ€§ç¼“å­˜**: åŸºäºè®¾å¤‡å†å²è¡Œä¸ºé¢„æµ‹çŠ¶æ€ï¼Œæé«˜ç¼“å­˜å‘½ä¸­ç‡
3. **è‡ªåŠ¨åˆ†åŒºç®¡ç†**: æ•°æ®åº“åˆ†åŒºè‡ªåŠ¨åˆ›å»ºå’Œæ¸…ç†ï¼Œæ— éœ€äººå·¥å¹²é¢„
4. **ä¼˜å…ˆçº§æ‰¹å¤„ç†**: å¤šé˜Ÿåˆ—å¤šçº¿ç¨‹å¤„ç†ï¼Œä¿è¯å…³é”®æ•°æ®ä¼˜å…ˆçº§
5. **å¤šç§Ÿæˆ·æŸ¥è¯¢ä¼˜åŒ–**: åŸºäºcustomerIdçš„åˆ†ç‰‡ç´¢å¼•ç­–ç•¥ï¼Œæ”¯æŒé«˜å¹¶å‘ç§Ÿæˆ·æŸ¥è¯¢
6. **è®¾å¤‡ç»‘å®šç¼“å­˜åŒæ­¥**: å¼‚æ­¥ç¼“å­˜æ›´æ–°æœºåˆ¶ï¼Œä¿è¯æ•°æ®ä¸€è‡´æ€§å’Œé«˜æ€§èƒ½

### 7.3 åç»­ä¼˜åŒ–æ–¹å‘

#### çŸ­æœŸä¼˜åŒ– (3-6ä¸ªæœˆ)
1. **AIé©±åŠ¨ä¼˜åŒ–**: åŸºäºæœºå™¨å­¦ä¹ çš„è®¾å¤‡æ•…éšœé¢„æµ‹
2. **è¾¹ç¼˜è®¡ç®—**: åœ¨è®¾å¤‡ç«¯è¿›è¡Œæ•°æ®é¢„å¤„ç†ï¼Œå‡å°‘ä¼ è¾“é‡
3. **æµå¼å¤„ç†**: å¼•å…¥æ¶ˆæ¯é˜Ÿåˆ—ï¼Œå®ç°çœŸæ­£çš„å®æ—¶æ•°æ®å¤„ç†

#### é•¿æœŸè§„åˆ’ (6-12ä¸ªæœˆ)
1. **å¾®æœåŠ¡æ²»ç†**: æ‹†åˆ†å•ä½“æœåŠ¡ï¼Œæé«˜ç³»ç»Ÿå¯ç»´æŠ¤æ€§
2. **äº‘åŸç”Ÿéƒ¨ç½²**: å®¹å™¨åŒ–éƒ¨ç½²ï¼Œæ”¯æŒå¼¹æ€§ä¼¸ç¼©
3. **å¤šåœ°åŸŸéƒ¨ç½²**: æ•°æ®å°±è¿‘å¤„ç†ï¼Œé™ä½ç½‘ç»œå»¶è¿Ÿ

### 7.4 æŠ•èµ„å›æŠ¥è¯„ä¼°

#### æˆæœ¬æŠ•å…¥
- **å¼€å‘æˆæœ¬**: 8äºº*6å‘¨ = 48äººå¤©
- **ç¡¬ä»¶æˆæœ¬**: Redisé›†ç¾¤ã€æ•°æ®åº“å‡çº§ â‰ˆ 5ä¸‡å…ƒ
- **è¿ç»´æˆæœ¬**: ç›‘æ§ç³»ç»Ÿã€è‡ªåŠ¨åŒ–å·¥å…· â‰ˆ 2ä¸‡å…ƒ
- **æ€»æŠ•å…¥**: çº¦15ä¸‡å…ƒ

#### æ”¶ç›Šè¯„ä¼°
- **æœåŠ¡å™¨æˆæœ¬èŠ‚çœ**: èµ„æºåˆ©ç”¨ç‡æå‡40% = å¹´èŠ‚çœ20ä¸‡å…ƒ
- **è¿ç»´æˆæœ¬é™ä½**: æ•…éšœç‡é™ä½80% = å¹´èŠ‚çœ10ä¸‡å…ƒ  
- **ç”¨æˆ·æ»¡æ„åº¦æå‡**: å“åº”é€Ÿåº¦æå‡75% = ç”¨æˆ·ç•™å­˜ç‡+15%
- **ä¸šåŠ¡æ‰©å±•èƒ½åŠ›**: æ”¯æŒ10å€è®¾å¤‡è§„æ¨¡ = ä¸šåŠ¡å¢é•¿æ½œåŠ›

**ROI**: ç¬¬ä¸€å¹´å›æŠ¥ç‡ > 200%ï¼Œé•¿æœŸæ”¶ç›Šæ˜¾è‘—

---

*æ–‡æ¡£ç‰ˆæœ¬: v1.0*
*åˆ›å»ºæ—¥æœŸ: 2025-08-31*
*ä½œè€…: Claude AI*
*å®¡æ ¸çŠ¶æ€: å¾…å®¡æ ¸*